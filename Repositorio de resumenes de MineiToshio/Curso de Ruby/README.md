# Curso de Responsive Design<!-- omit in toc -->

## Tabla de Contenido<!-- omit in toc -->
- [Introducci√≥n](#introducci√≥n)
- [Instalaci√≥n](#instalaci√≥n)
- [Variables](#variables)
- [Integer y Flotantes](#integer-y-flotantes)
- [Strings](#strings)
- [Symbols](#symbols)
- [Arrays](#arrays)
- [Hashes](#hashes)
- [Rangos](#rangos)
- [Condicionales](#condicionales)
- [Ciclos](#ciclos)
- [Uso de regex](#uso-de-regex)
- [Procs y lambdas](#procs-y-lambdas)
- [Clases](#clases)
- [Enlaces de Inter√©s](#enlaces-de-inter√©s)

## Introducci√≥n

Ruby es un lenguaje de programaci√≥n creado por Matz en 1995, es open source y fue popularizado por Rails en 2005. Este lenguaje es din√°mico, interpretado y orientado a objetos (todo es un objeto). Su objetivo es la felicidad y productividad del desarrollador.

**Ventajas**

* Comunidad muy grande
* Muchas librer√≠as
* Constantes actualizaciones
* Lenguaje maduro

**Desventajas**

* Interpretado puede significar lento
* Alto uso de memoria
* No paralelismo
* Ha venido decreciendo en popularidad

## Instalaci√≥n

1. Descargar el instalador desde aqu√≠ https://rubyinstaller.org.
2. Aceptar la licencia.
3. Escoger la carpeta de instalaci√≥n.
4. Usar UTF-8 como external encoding.
5. Continuar la instalaci√≥n con los valores por defecto.
6. Se abrir√° una ventaja de consola. Apretar Enter.

Para comprobar si Ruby se instal√≥ correctamente:
1. Ir a la consola.
2. irb
3. RUBY_VERSION 
4. exit
5. ruby -v

## Variables

Deben empezar con un letra min√∫scula o un gui√≥n bajo (_), se recomienda el uso de la convenci√≥n "snake_case" con el fin de identificarlas f√°cilmente y no puede contener palabras reservadas del lenguaje.

En Ruby, todas las variables son tratadas como objetos. De ese modo, toda las variables tienen m√©todos.

Algunos m√©todos son:

* `x.class` (Para preguntar de qu√© clase es la variable).
* `x.methods` (Para enlistar los m√©todos que puede usar la variable).
* `x.odd?` (Para verificar si la variable es impar, devuelve un booleano).
* `x.even?` ( Para verificar si la variable es par, devuelve un booleano).

Cuando un m√©todo termina en interrogante (?) va a devolver un booleano (True o False).

## Integer y Flotantes

**Operadores**

X = 5

* `Suma` X + 5
* `Resta` x - 6
* `Divisi√≥n` X / 7
* `Multiplicaci√≥n` X * 4
* `M√≥dulo` X % 3
* `Potencia` X ** 2

Cuando hay una operaci√≥n aritm√©tica entre enteros resulta entero, pero cuando hay una operaci√≥n aritm√©tica entre entero y un flotante resulta un flotante (Decimal).

## Strings

Un string se puede definir de las siguientes forma:

* `s = "hola"`
* `s = 'hola'`
* `s = %q(hola)`
* `s = %Q(hola)`

**Interpolaci√≥n**

```ruby
/*Permite interpolaci√≥n*/
saludo = %Q(Hola #{nombre})
saludo = "Hola #{nombre}"

/*NO permite interpolaci√≥n*/
saludo = %q(Hola #{nombre})
saludo = 'Hola #{nombre}'
```

**M√©todos**

* `"hola".upcase` (Devuelve una copia de la cadena en may√∫sculas)
* `"hola".downcase` ( Devuelve una copia de la cadena en minusculas)
* `"hola".length` (Devuelve la cantidad de caracteres de la cadena)
* `"HoLa".swapcase` (Devuelve una copia de la cadena con caracteres alfab√©ticos en may√∫sculas convertidos a min√∫sculas y viceversa)
* `"hola".include? "h"` (Devuelve true si el car√°cter asignado entre est√° incluido en nuestra cadena o variable)
* `" hola".strip` (Devuelve una copia de la cadena con caracteres alfab√©ticos en may√∫sculas convertidos a min√∫sculas y min√∫sculas convertidos a may√∫sculas)
* `"".empty` (Devuelve true si la cadena est√° vacia)
* `"Hola ruby".gsup("ruby", "mundo")` (Devuelve una copia de la cadena con todas las apariciones de patr√≥n sustituidas por el segundo argumento)
* `gsub!` (Para modificar la variable en ves de devolver una copia)

**Operadores**

* `"Hola" + "Mundo"` Concatena 2 strings.
* `"Hola" * n` Multiplica un string n cantidad de veces.

## Symbols

Los symbols son un tipo de dato especial que utiliza Ruby para declarar constantes, esto existe para evitar que se generen m√°s objetos y por lo tanto, no generar espacio de memoria adicional.

Para declarar un s√≠mbolo se utilizan los dos puntos

`color = :rojo`

## Arrays

Un array o arreglo es un tipo de datos especial donde vas a poder almacenar m√∫ltiples objetos en una sola variable.

Ejemplo:
`letras = ["q", "w", "e", "r", "t", "y"]`

Algo interesante de Ruby es que podemos utilizar n√∫meros negativos para acceder a las posiciones desde el √∫ltimo elemento del array.

Los arreglos en Ruby no tienen un tipo espec√≠fico, esto quiere decir que dentro de un array podemos tener diferentes tipos de datos en cada elemento.

Ejemplo:
`arreglo = [4, 4.6, "string", :symbol, [1, 4, 6]]`

Si se usa un √≠ndice fuera del rango, el valor va a devolver nil.

**M√©todos**

* `letras.include? "y"` Devuelve true si incluye dicho elemento
* `letras.first` Devuelve el primer elemento
* `letras.last` Devuelve el √∫ltimo elemento
* `letras.count { |x| x == "y" }` Nos retorna la cantidad de elementos que cumplen dicha condici√≥n
* `[1,2,3,4,5].map { |x| x*2 }` Nos retorna un arreglo modificado seg√∫n la condici√≥n
* `[1,2,3,4,5].select { |x| x.even? }` Nos retorna un arreglo con los elementos seleccionados seg√∫n la condici√≥n
* `[1,2,3,4,5].min` Nos va a retornar el elemento m√°s peque√±o
* `[1,2,3,4,5].max` Nos va a retornar el elemento m√°s grande
* `[1,2,3,4,5].sum` Retorna la suma de todos los elementos del arreglo
* `"Hola Mundo".split(" ")` Nos retorna un arreglo con la cadena dentro separada por el elemento dentro del par√©ntesis
* `["a", "b" ,"c"].join("-")` Retorna los elementos de una matriz en una cadena separada por el elemento dentro del par√©ntesis
* `letras.sort` Nos retorna una copia ordenada del arreglo

## Hashes

Hashes, tambi√©n conocidos como arrays asociativos, mapas o diccionarios, son parecidos a los arrays en que son una colecci√≥n indexada de referencias a objetos. Sin embargo, mientras que en los arrays los √≠ndices son n√∫meros, en los hashes se puede indexar con objetos de cualquier tipo.

Cuando se almacena un valor en un array, se dan dos objetos: el √≠ndice y el valor. Luego, se puede obtener dicho valor, gracias al √≠ndice.

Los hashes se pueden declarar de 2 formas:

````ruby
capitales = { "Colombia" => "Bogot√°", "Per√∫" => "Lima" }

capitales["Mexico"] = "Ciudad de Mexico"
````

**M√©todos**

* `hash.size` Retorna la cantidad de parejas guardadas en el hash
* `hash.empty?` Indica si el hash est√° vac√≠o
* `hash.has_value? "Washington"` Verifica si el hash tiene el valor
* `hash.has_key? "Washington"` Verifica si el hash tiene ese key
* `hash.invert` Intercambia los valores por las llaves
* `hash.merge({"Marte" => "Musk"})` Junta 2 hashes
* `hash.transform_values { |x| x.downcase }` Transforma todos los valores en base a una regla determinada
* `hash.map { |k,v| "La capital de #{k} es #{v}" }` Ejecuta un comando a todas los registros
* `[["pepito", 13], ["sutanito", 14]].to_h` Convierte un arreglo a hash

## Rangos

El principal uso y quiz√°s el m√°s apropiado para los rangos, es expresar una secuencia: las secuencias tienen un punto inicial y un punto final, y una forma de producir los sucesivos valores entre ambos. En Ruby, esas secuencias son creadas usando los operandos ".." y "..."

* ".." genera una secuencia donde los puntos l√≠mites est√°n incluidos.

#Equivale a 1, 2, 3
`(1..3).to_a`

* "..." genera una secuencia en la que no est√° incluida el l√≠mite superior.

#Equivale a 1, 2, 3, 4
`(1...5).to_a`
 
## Condicionales

```ruby
role = :superadmin

if role == :admin
  puts "pantalla de admin"
elsif role == :superadmin
  puts "pantalla de superadmin"
else
  puts "pantalla de login"
end
```

## Ciclos

```ruby
while condicion do
  puts "hola"
end

#Loop es infinito. Si se quiere salir se usa u break.
loop do
  puts "hola"
  break if condicion
end

for i in i..10 do
  puts "hola"
end

[1,2,3,4].each { |x| puts "hola" }

#El rimer n√∫mero es el l√≠mite. En este ejemplo ir√≠a de 0 a 3.
4.times { |x| puts "hola" }
```

## Uso de regex

Para declarar un regex, se utiliza el "/" , ejemplo:

`is_gmail_regex = /\w+@gmail.com/`

## Procs y lambdas

```ruby
saludar = Proc.new { |nombre| puts "Hola #{nombre}" }
```

## Clases

```ruby
class Persona
  #M√©todo
  def self.suggested_named
    ["Pepe", "Pepito", "Pepon"]
  end

  #Constructor
  def initialize(name, age)
    @name = name
    @age = age
  end

  #Getter
  def name
    @name
  end

  #Setter
  def name=(name)
    @name = name
  end
end

#Instanciar clase
persona = Persona.new("Pepe", 14)
puts persona.Name

#User m√©todos
Persona.suggested_named
```

Otra forma de crear clases:

```ruby
class Persona
  attr_accessor(:name, :age)  # Genera getter y setter

  def initialize(name)
    @name = name
  end
end
```

M√©todo de crear clases con struct

```ruby
#Struct declara el constructor, getters y setters
class Persona < Struct.new(:name, :age) 
end
```

## Enlaces de Inter√©s
* [Curso de Ruby](https://platzi.com/clases/ruby/)
* [Ruby Installer](https://rubyinstaller.org)

<div align="right">
  <small><a href="#tabla-de-contenido">ü°° volver al inicio</a></small>
</div>